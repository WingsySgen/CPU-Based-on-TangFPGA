### 常量与指令集

此处仅介绍指令集用法以供想要快速实现功能的人使用。常量与指令集不区分大小写，在映射程序中会同统一转到大写处理。常量与指令集都可以看作是一个常数的别名，所以它们之间都能互相运算。支持加、减、或、异或、与五种运算。

指令集主要可以分为四类，分别是运算指令，条件指令，访存指令和函数指令。

##### 常量

常量不是指令，但可以增加代码的可读性。

#0到#11号寄存器的命名规则是regxx，或者也可以用reg|xx、reg+xx等运算来表达。剩下四个寄存器命名分别是IOAD，IOC，TIMER，PC。

向IOAD写入对IO的选择时，这里提供了对应的常量。比如spi是0，spi.flg（SPI的标志寄存器，参考高云IP核手册）是4，uart是16，uart.lsr（UART的线状态寄存器，参考高云IP核手册）是21，方便使用。

同时接受常数的二进制和十六进制的表达，使用0b或0x作为前缀。

还有两个特殊常量im1与im2，和指令相或来表示该条指令的第一个/第二个参数是立即数。

##### 运算指令

运算指令包括：add、sub、and、or、not、xor、mov、mull、mulh、lsh、rsh、div、mod、car。

其中mull和mulh是乘法，一个返回结果的低八位一个返回结果的高八位。lsh和rsh是逻辑左移和逻辑右移。car返回上一次加法是否进位。

除了mov和not这两个单目运算以及car这个输出进位标记的指令外，其余的双目运算均从前两个参数所示的寄存器/立即数取值，进行运算后赋值给第三个数所示的寄存器。

mov和not的第二个参数留空，用$\_$占位。car不接受前两个参数。

```
add|im2 reg1 1 reg1
mov|im1 10 _ reg5
car _ _ reg2
```

##### 条件指令

条件指令包括：je、jne、js、jse、jg、jge、jmp。

条件指令第三个参数一定是一个常数，或者说是一条label名，满足条件时将这个数覆盖到PC中去。

jmp是无条件跳转，不接受前两个参数，PC会无条件跳转到第三个参数指示的位置。其它六条指令接受前两个参数指示的寄存器/立即数，当为真时跳转到第三个参数所示的位置。j是judge，s是smaller，g是greater，e是equal。

```
lebel loop_1
	je|im2 reg1 10 loop_1
```

##### 访存指令

访存指令包括：memr、memw。

这两条指令都会把第二个参数指示的寄存器/立即数作为地址输入到RAM中。

当指令为memr时，指令不接受第一个参数，会把读到的值赋值给第三个参数指示的寄存器。

当指令为memw时，指令不接受第三个参数，会把第一个参数指示的寄存器/立即数写入RAM对应的地址上。

```
memr|im2 reg10 0x0a _
memw _ reg7 reg8
```

##### 函数指令

函数指令包括：call、ret。

call不接受前两个参数，第三个参数的要求同条件指令一样。会先将PC当前的值+1后压入PC模块内一个32字节的栈中，在这之后call的行为相当于jmp。

ret不接受任何参数，仅仅是指示PC将栈顶元素出栈并覆盖PC当前的值。

```
label func
	add reg1 reg2 reg1
	ret _ _ _

call _ _ func
```

##### 伪指令

目前支持的伪指令仅有一条：label。

使用label xxx来使得xxx变为它下面一行指令的行号，label会在代码文件开始被映射到比特流之前被展开并识别。

