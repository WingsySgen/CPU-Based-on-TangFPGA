### 开发者日志

***

- [2023.11.5](#2023.11.5)
- [2023.12.24](#2023.12.24)
- [2023.12.26](#2023.12.26)
- [2023.12.29](#2023.12.29)
- [2024.1.20](#2024.1.20)
- [2024.2.4](#2024.2.4)
- [2024.3.7](#2024.3.7)
- [2024.3.27](#2024.3.27)
- [2024.4.22](#2024.4.22)
- [2024.4.24](#2024.4.24)
- [2024.5.17](#2024.5.17)
- [2024.5.18](#2024.5.18)
- [2024.5.19](#2024.5.19)

#### 2023.11.5

***

关于PC：

立即数在这里被认为是个12位的有符号数，而除了立即数外，PC还应当支持从寄存器获取32位的值，同时出栈的也是一个32位的绝对值。但是PC本身无法判断从data_in输入的位宽。这里引入wt_type来告知PC应当以何种方式处理输入，同时每种条件指令都应当有其增量版本和常量版本。该信号应当由COND发出。

1. PC做出更改
2. COND支持wt_type



关于ID：

剥离不属于ID的功能，比如发出中断撤销信号的功能。对于运算、条件、内存的三种指令，ID不应该再涉及任何具体的执行部分。除此之外，扩展指令目前可以由ID来处理。为了方便扩展，最好还是交付给一个专门执行扩展指令的模块。



关于指令集：

旧的指令格式如下：

```
1:0    3:2      9:4      14:10    19:15    24:20
imm    type    opcode    para1    para2    para3
 2b     2b       6b       5b       5b       5b
```

但是当指令种类为扩展时，有些时候并不需要imm的参与。

调换imm与type的位置，新的指令格式如下：

```
1:0    3:2      9:4      14:10    19:15    24:20
type   imm     opcode    para1    para2    para3
 2b     2b       6b       5b       5b       5b
```



#### 2023.12.24

***

中断控制器(*Interrupt Controller*)无误地完成了。至此，CPU终于获得了能够稳定、及时地与外界交互的能力。

INTC支持64优先级中断，支持低优先级中断被高优先级中断打断的中断嵌套。

该模块是进入32位系统开发以来遇到的最大最棘手的问题。接下来我会阐述debug的阶段、bug发生的原因以及解决方法。

具体过程由手稿详细记录。

##### 开始 - 2023.12.16

***

该阶段至少从2023.12.16开始，这段时间没有留下手稿。

在这个阶段中，中断控制器用的是最初的版本，这时INTC还在仿真阶段。

12.16有记录的bug如下：

> 中断不能正常触发
> 原因：改变中断使能的逻辑之后忘记修改sr内的内容

产生这个bug的时候应该是在测试 *6.基础中断测试*。

这个bug的产生原因是在这之前中断使能寄存器组采用的是负逻辑，低电平有效。在12月16日我把中断使能寄存器组的逻辑变更为了高电平有效，做出这个更改之后忘记改变INTC内部SR输入的逻辑产生了这个bug。

在这之后，第六项测试成功。之后进入第七项测试。

##### 2023.12.16 - 2023.12.19

***

应该在2023.12.18，WIMM寄存器通过了测试。我为所有GPR都添加了直通#C总线的能力，但是只有WIMM寄存器被允许这样做。

12.19第一个有记录的bug如下：

> 不能进入中断
>
> 原因：没添加IOAD的直通#C使能，对LED组的修改被修改到了中断使能寄存器组。

字面意思，IOAD也是由GPR例化而来的，我在修改直通#C的时候修改了通用寄存器，修改了WIMM，但是忘记了修改IOAD。



接下来的记录总结自手稿。从这里开始都是在测试 *9.外部中断测试*。

12.19记录的bug中，基本都与外部中断有关。这时的testbench文件是在一个非时钟周期（大概是#53）的间隔下反复拉高拉低按钮以测试外部中断。

在非周期的情况下，出现了这样一种情况：中断到来之后，PC没有做出反应，而INTC进入了中断。

这是由于外部中断在周期的后半段（下降沿之后）到来，而PC已经在下降沿变化，不能捕捉到这个中断信号，但是正常时钟的INTC在下个上升沿到来时认为PC已经接受了这个信号，然后INTC被赋值。

手稿上列出了两个解决办法：

>1. 栈指针寄存器和INTC通反向时钟
>2. 外部中断拉高至少经过一个上升沿才会被报告给PC。

显然，PC和RAM通入反向时钟已经是无奈之举，在有其它解决方案前，不应该再扩大通反向时钟的模块了。同时，SP(*Stack Pointer*)和INTC被修改为在时钟下降沿动作可能会引入新的不确定因素。

而且更加显然的是，解决方案2足够简单。

进一步解释，由于在这之前通过除零或者int拉起的软中断已经通过了测试，所以我们已知在一个周期的开始就拉高中断可以使PC正常的进入中断，所以对于外部中断同样可以采用这个方法。把突发地变成规律地，尽管这个规律也是突发的。

##### 2023.12.20 - 2023.12.21

***

12.20没有留下手稿，12.21留下了四篇手稿。这四篇手稿提出了数个问题，然后解释、证明了这些问题。

接下来的记录总结自手稿。同样这里是在测试*9.外部中断测试*。

12.21用的INTC的结构是我早在十月份左右就完成的一份代码（128bit版本，通过简单的删除得到了intc_64bit_plan_b.v）。实际上到12.21我只知道自己的想法，但是已经不清楚具体实现了，12.21首先分析了INTC的结构。

首先，通过规整外部中断的信号，仿真的结果已经合乎预期，但是烧录之后仍然存在问题，通过在线逻辑分析仪可以看到INTC中采用组合逻辑的SR，其波形不符合预期，同样不符合仿真。表现为data在set为0、reset为0时被重置为了0。所以我不得不从INTC重新开始分析。



2023.12.21(1)分析了INTC的结构。之后的手稿中，通过分析INTC的结构，我发现了当前的INTC结构存在的严重bug，表现在于中断的嵌套方面。

> Q1：
>
> 1. 低优先中断被高优先中断打断
>2. 高优先中断过程中发生了低优先中断

这时我对INTC的想法是在高优先级的过程中如果发生了低优先级中断，INTC需要保存这个状态，然后在高优先级中断完成之后返回去执行低优先级中断。这样会产生两种基础情况：1. 嵌套。2.累加（高优先中断iret后进行低优先中断）。
> 
>想法1：设置一个“中断中”的标志位，为0说明回到了主程序。
> 
> 想法2：设置一个“中断层数”的标志寄存器，每中断一次+1，返回一次-1。

这两个幼稚的想法既不优雅，又没有从根本上解决问题。嵌套和累加只是基础情况，这两种情况完全可以任意叠加，出现任意一种组合（评价为经典的hack）。

对于这个问题，手稿里给出了如下解释：

> 首先，软中断之间不会同时发生，只有计时器中断和外部中断才会，这类中断可以长时间被外部拉高，所以可以暂时屏蔽。
>
> 那么，2情况不再有效，只用考虑1的情况。

> A1：多个中断叠加，后面的中断（这里指发生时间的后面）一定是外部中断（因为通过指令拉起的软中断一定是通过指令拉起的，注意这点，“不请自来”的一定是外部中断）。这些中断可以晚几个周期响应。
>



在(4)中，我给出了新的INTC的结构：

> 当一个中断发生时，屏蔽所有低级中断。

这个想法是有效的。但是在旁边记录了这样一句话：

> 不考虑外部中断与软中断在同一周期同时拉高的可能。

这个想法就是非常愚蠢的了。



同时为了解决组合逻辑SR的问题，我把组合SR改为了时序SR。这样再一次引入了新的问题，所有中断的触发时间被拉长到了两个周期，包括软中断，软中断必须能够在一个周期内立马响应。

> 软中断不再由INTC通知PC，而是由COND通知。硬中断仍然由INTC通知PC。

这样，软中断就被恢复到了一个周期。

##### 2023.12.22

***

12.22共有三篇手稿。

继承自12.21，软中断的响应时间恢复到了一个周期，硬中断仍然保持两个周期。

此时烧录到开发板上，开发板每秒拉起一个软中断对LED组取反可以实现，通过按钮拉起的中断来熄灭LED组也可以实现，但是当按钮按下的时间过长，或者在LED即将变化的时候按下，那么按钮就再也不能拉起中断了。

通过在线逻辑分析仪可以看到，INTC最后被保持在了按钮中断的中断号没有被撤销。通过仿真，发现了这是外部中断和软中断同时发生导致的。

分析的波形图在(1)上，简而言之：

> SINT的启动只占一个周期，HINT占两个周期。如果HINT在$T_1$拉高，那么在$T_2$写入SR，INTC也就会在$T_2$向PC报告有外部中断了。
>
> 但是如果$T_{1.5}$的PC指向的是一条INT，那么在$T_2$，PC会同时收到由软中断和硬中断拉起的中断，这样PC根本不知道有几个中断，也只会iret一次。这样使得中断号被永久留在了INTC中。

至此，修复的方向如下：

> 1. 软件解决。中断入口程序用call调用中断函数，中断函数ret返回。返回之后撤销这次中断然后判断INTC，如果不为0x3f那么再来一次中断。
> 2. HINT重新延长到两个周期。
> 3. SINT缩短至一个周期。
> 4. SINT暂停CPU一个周期。

方案1意味着放弃iret这条指令，同时也是一个治标不治本的方法，还很不优雅。需要人工手动干预SP。

方案2不可行，通过int指令拉起的中断能在后面加一条nop解决，但同样不优雅。而且软中断还可以由一些错误引发，不能对所有能够引发错误的指令后面都加一条nop。

方案3意味着SR需要重新做回组合逻辑。而且重点在于SINT如果缩短至一个周期，其和HINT的冲突仍然需要考虑。

方案4需要更改大量的硬件结构。

似乎无解了。

##### 2023.12.23

***

12.23共有两篇手稿。

首先针对12.22留下的问题，我写下了两个想法：

> 1. 能否取消SR触发器。
> 2. SINT调整为一个周期。

方案1无论怎么说，都使INTC就失去了保存上下文的能力，必须依赖stack保存中断号。

那么怎样把SINT缩短至一个周期的同时避免SINT和HINT竞争？

> 1. 硬中断的拉起信号直接通过使能判断报告PC，与软中断同一个步骤。
> 2. 拉起过程中“压住”低优先级中断。

也就是如果高优先级中断和低优先级中断在拉起的时候就进行优先级比较。这个想法很简单，但由于之前的工作使得我迟迟没有想到这个方向上面来。

这时仿真仍然存在问题，中断号仍然被留在了INTC中，经过排查发现是iret之后INTC没有正确动作。

> 首先，如果中断内拉低了中断使能寄存器，
> reset会被en阻挡，
> reset不该被en阻挡。
>
> 其次，带有set_in逻辑关系的前缀或只应该应用在“压”输入上，而不应该输入编码器模块，否则会使中断无法ret。
> 解释：表现为旧中断的SR位清楚，但由于外部仍然拉高，使得第63位，默认的优先级被“压住”了。

更改之后烧录，此时开发板表现的问题是软中断正常，但是使用一次按钮拉起的中断过后LED组就不会再亮起。

##### 2023.12.24

***

通过在线逻辑分析仪排查，发现是软件问题。

```
label int_btn
    mov 1 _ ioad
    not reg0 _ reg25
    sub reg25 1 ioc
    mov 256 _ ioad
    mov 15 _ ioc
    iret _ _ _ 
    
label sleep
    add timer 1000 reg25
    label sleep_1
        jne timer reg25 sleep_1
    ret _ _ _
```

在第12行的过程中触发中断，reg25会被永久改变为-1，导致进入一个时间非常长的等待中。

更改之后，中断的一切行为均符合预期了。



#### 2023.12.26

***

2023.12.26的版本作为第一个稳定版，已经完成了对硬件结构的基础实现。现在，CPU被命名为**SG32D**。

包括：基础逻辑算数运算、访存、中断系统，以及挂载在CPU模块内的一个UART模块。

该UART模块挂载在8号IO上，中断号32。



关于IO与中断：

SG32内部保留16个IO接口，其它接口开放到模块外部。SG32的IO数目可在例化软核时通过传参调节，但不小于16个。

SG32固定有64级中断，中断号0-63，有15个向模块外部开放。其中63作为默认中断号被占用，0-31被CPU作为软中断占用，32-47被CPU模块内部外设占用，48-62开放到外部。



#### 2023.12.29

***

##### 外设优化

对外设控制器进行了优化，同时IO_Template也进行了更改。

在之前的版本中，IOC引出了外设数量的片选线，但是同时又毫无意义地引出了外设数量的读写使能线。

同时这些读写使能线仅仅标识了写使能，写时为1，读时为0。对于一部分外设来说这样的设计可以符合要求，但对于另外一些对读写拉高的周期有严格要求的模块来说并不符合其设计。

现在IOC引出外设数量的片选线，外设数量的读写使能线被修改为一根读使能线和一根写使能线。IO模板如下：

```verilog
module Template
(
    input   wire            clk,
    input   wire            rst_n,

    inout   wire[31:0]      data_io,
    input   wire            cs_en,
    input   wire            wt_en,
    input   wire            rd_en,
    input   wire[3:0]       addr_in
    
    /*
    自定义接口
    */
);
    wire[31:0]  wdata;
    wire[31:0]  rdata;
    assign wdata = wt_en && cs_en ? data_io : 32'dz;
    assign data_io = cs_en ? (wt_en ? 32'dz : rdata) : 32'dz;
    assign addr = cs_en ? addr_in : 4'b1111;

//    wire wrx = cs_en ? wt_en : 1'b0;
    
    /*
    自定义行为
    */
    
endmodule
```



#### 2024.1.20

***

改进了汇编器，包括函数名的命名方式、LinePack类的成员等方面。

##### const与string

汇编器现在能够额外支持const和string两条伪指令了，目前共支持label、const、string三条伪指令。

用法如下：

```
const constant001 0x01
string string001 Hello_World
```

const会定义一个对下文生效的常量。不会检查重复，每次都会覆盖上一次的值（如果存在的话）并重新对下文生效。

string会定义一个对下文生效的常量。字符串内容会被写在ram中，被定义的常量指向这个字符串的起始地址，检查重复。目前这个字符串仅支持由大小写字母以及数字组成的字符串。

##### 一些问题

但是在当前版本中，const和string定义的常量被保存到了同一个表中，这意味着被const定义过的常量名不能作为string的字符串名，被string定义过的字符串名会被const的同名常量覆盖，而汇编器不会去检测这个行为。

##### 细节变更

更换了一些函数的名称。

LinePack类中存三个操作数信息的从三个独立的变量改为了一个大小为3的数组以方便运算。

label更名为了label_table。table从原来的一个表分成了op_table、const_table、reg_table三个表。

限制了每行指令第一个词必须来源于op_table，剩下三个词可以来自reg_table以及const_table，如果不存在那么认为是一条label等待回填。



#### 2024.2.4

***

##### 串口烧录

支持了串口烧录，通过核内内置的UART0进行烧录。

通过板载的S3来切换到BOOT引导部分，按下S3之后按下S0进行重置会进入到引导程序中，这时使用上位机进行串口烧录。

为了配合这一部分功能，汇编器进行了如下改动/更新：

1. 汇编器不再负责输出.mi文件，而是输出一个二进制文件。该二进制文件格式如下：

    - 起始四个字节为该文件中包含的条目数。
    - 每个条目由八个字节组成，前四个字节为地址，后四个字节为内容。
    - 每四个字节小端序存储。

2. 汇编器支持了一条新的伪指令：locate。其用法如下：

    ```
    locate 0x100
    ```

    locate会将当前的行号更新为locate后面的整数。目前locate指令没有做任何的检测，用户应该主动注意locate是否合法。

目前的默认程序中为基础系统程序预留了256条指令的空间，并把用户自定义的程序入口定在了0x100的位置。因此可以使用locate 0x100来进行保留基础系统的编程。



#### 2024.3.7

***

对汇编器进行了重构，版本号来到了2.0。

##### 伪指令include

正式支持了include伪指令。通过include伪指令在调用处立即展开为include所指向的文件以完成静态链接。

```
include uart
call _ _ uart_rd
```

在对include所指向的文件进行汇编时，汇编器会对标签表和常量表进行隔离。具体表现为外部的标签和常量对内部不可见，内部的标签和常量对外部不可见，以防止更多文件链接时造成的标签混乱。

同时允许对一个文件进行多次include，只会在第一次include展开该文件。以支持多个文件依赖同一文件的情况。

为了让被指向的文件提供对外部的接口，新增了新的伪指令global以配合include使用。

##### 伪指令global

支持了global伪指令，用法与label类似。global使得标签对外部可见以提供接口。

```
#uart.code
global uart_rd          #对外部可见
    label uart_rd_1     #对外部不可见
```

##### 文件对象类SrcCode

为了实现include以及进一步的代码解耦与模块化，汇编器的实现发生了一些改变。

现在每个文件都被封装成了类SrcCode，汇编的过程对外部不可见。

在使用之前，需要调用SrcCode::initStaticVar()来初始化类的静态变量。

对外部而言，可以通过构造函数初始化一个文件对象，并调用接口doAsm()来进行汇编。doAsm()会返回该对象在汇编完成后的行数、文本、扩展行信息以及全局指令表以供上一级进行处理。

##### 伪指令表类PseudoTable

在1.2之前的版本中，伪指令通过if-elif-elif-...判断，当伪指令的需求越来越多的时候性能会越来越差。1.2版本中，新增了伪指令表，并在2.0版本中进一步和文件对象进行了适配。通过伪指令表，汇编器的性能得到了一部分的增强，并能够更加方便地添加新的伪指令。

伪指令表类PseudoTable，内部由一个std::map<std::string, std::function<void(std::vector<std::string&, SrcCode&>)>>组成，是字符串对函数的映射。当检测到一条伪指令时，直接通过在这个表中注册的映射调用相应的函数。类PseudoTable是类SrcCode的友元类，因此其成员函数可以访问SrcCode的私有变量。

pseudo.h中，对PseudoTable的定义内容如下：

```cpp
class PseudoTable{

public:
    map<string, function<void(vector<string>& line, SrcCode& src)>> pseudo_table;
    static void pseudo_label(vector<string>& line, SrcCode& src);
    static void pseudo_const(vector<string>& line, SrcCode& src);
    static void pseudo_string(vector<string>& line, SrcCode& src);
    static void pseudo_locate(vector<string>& line, SrcCode& src);
    static void pseudo_include(vector<string>& line, SrcCode& src);
    static void pseudo_global(vector<string>& line, SrcCode& src);

    PseudoTable(){
        pseudo_table["label"]   = &pseudo_label;
        pseudo_table["const"]   = &pseudo_const;
        pseudo_table["string"]  = &pseudo_string;
        pseudo_table["locate"]  = &pseudo_locate;
        pseudo_table["include"] = &pseudo_include;
        pseudo_table["global"]  = &pseudo_global;
    }
};
```

当需要添加新的伪指令时，只需要添加一个新的成员函数在类中，并在构造函数中添加相应的初始化行为，接下来创建一个.cpp文件定义新添加的伪指令行为并编译即可。模板如下：

```cpp
#include"pseudo.h"
#include"basiclib.h"
#include"SrcCode.h"
using namespace std;
/*
line是被处理的一行伪指令，比如这样一行伪指令：
    label temp
那么line[0]是字符串"label"，line[1]是字符串"temp"。

src是调用到这行伪指令的源文件，由于友元，该函数可以访问src的所有私有变量。
*/
void PseudoTable::pseudo_template(vector<string>& line, SrcCode& src){
    //自定义行为
}
```



#### 2024.3.27

***

进一步完善了2.0版本。由于之前的2.0版本实际上存在bug，所以版本号不变。

##### 旧的问题

由于在处理include伪指令时，汇编器会把子代码的信息合并到父代码的末尾，这个行为产生了bug。SrcCode::text等变量是直接预处理好的，直接追加到末尾会导致问题，而插入到中间的复杂度开销过大，因此对预处理的部分进行了优化。现在不再进行任何预处理，读入一行时就会把这行处理并解析。

除此之外，SrcCode::global_table在之前的类型是一个map，但实际上汇编过程中不会从这个表中查找内容，仅仅会在include返回中向父代码返回信息时使用。现在将其更改为vector，减少时间与空间的开销。

##### 字符串解析器

在之前的版本中，由于预处理的存在，所有的文本被全部读入之后，立即会被全部去除前后导分隔符并转变为小写。这样的处理方式使得string、include这样的伪指令使用起来并不方便，比如在一个有需要大写字符存在的字符串的情况下，或者是需要一些转义字符、空格等特殊字符存在的情况下。

现在，预处理的过程被删除了，同时引入了字符串解析器stringAnalyzer()，包含在basiclib.h中。字符串解析器允许使用双引号引入字符串，保护字符串内的大写字母与分隔符，正确识别转义等特殊字符。同时string与include开始强制检查字符串。

pair**<**vector<char>, int> stringAnalyzer(const string& str)，接受一个字符串，返回一个pair，first是解析后的字符串内容，second是将该字符串引用起来的反双引号在原串中的位置。使用状态机实现。



#### 2024.4.22

***

##### 汇编器相关

之前在处理重复include时，汇编器会直接忽视该条include。这会导致当某条include内部中include了一个已经在外部include过的文件时，由于include对外部信息的屏蔽，导致并不能正确获取被include的接口信息。

现在解析过的文件会被存储下来，当include一个文件时，如果这个文件已经被include，那么直接会从保存的对应内容中提取信息。保存在map<string, SrcCode*> SrcCode::include_tag 中，代替原本的buk变量。



#### 2024.4.24

***

修复bug。

##### 片上内存失效

这个bug的发现源于使用string伪指令时，软核不能正确通过uart输出。

经查找这个问题最终出现在在增加boot部分的逻辑时，没有声明ram的输出，导致位宽默认为1。



#### 2024.4.25

***

##### const分配栈上空间

现在，const支持第二个参数填入一个特殊的字符串“autoalloc”

并且当第二个参数是autoalloc时，支持填入一个整型当作第三个参数，留空则默认为1。

```
const var autoalloc 
const arr autoalloc 10
```

汇编器将在栈区划分对应的空间，并将起始地址作为该常量的值。



#### 2024.5.17

***

##### 关于栈的一些问题

至少到现在，SG32D都没有严格的栈区。

SG32D有一个1024*4字节的栈，但是这个栈只被用来存放函数或中断调用时的PC信息，而且SG32D还没支持POP和PUSH指令，只有CALL、INT、RET、IRET能够操作这片空间，或者由MEMW和MEMR直接操作。

提到POP和PUSH，不支持这两条指令是因为在最开始的八位机SG8上，PC使用的是自身的一个硬件栈，只有32字节，也就是最多递归32次，256的寻址使得添加这两条指令没有丝毫必要。SG32D也可以用两条指令完成POP与PUSH。但是实际上调用与返回的实现中已经完成了POP和PUSH所必要的硬件结构，所以现在其实可以考虑添加POP和PUSH。

汇编器视角上，从0x140(320)开始的所有内存都是可分配的。比如每定义一条string，汇编器就会直接将这部分内容排在已经分配的空间后面。

而使用const分配的方式也是有问题的（先不谈const不检查同名的缺点，这一点在2024.1.20就提到过），分配空间的const不会展开出任何指令，只会被汇编器处理一次，因此const只能被处理一次，更致命的是这个变量根本不会被销毁。因此无论怎么看。使用const分配的空间无论如何都像是static修饰的静态变量，如果一个函数中希望实时定义局部变量，那么最好使用其它手段，比如正式的栈操作。

##### 修复日志bug

汇编器2.0的日志输出存在bug。表现为在存在include伪指令时，日志最后的总结“地址——字符串——二进制”错位，字符串与另外两项不符。

这是由于输出这一段日志使用扩展行信息中的原始行去原文本中寻找，而在include中的原始行是基于include内而言的。解决方法是新创建了一个变量——带有展开include的原始行，使用这个变量去进行查找即可。



#### 2024.5.18

***

##### POP与PUSH

现在，SG32D支持POP与PUSH两条指令了

```
PUSH source _ _ 
POP _ _ target
```

PUSH会将第一个操作数压入栈顶

POP会将栈顶赋值给target的同时出栈



#### 2024.5.19

***

##### RAM类

SrcCode类中与ram有关的变量现在被换成了封装好的RAM类。

RAM类提供以下接口：

- 申请静态区空间
- 申请栈区空间
- 开辟新代码块
- 删除最近一个代码块
- 导出二进制接口文件

##### 伪指令展开

为SrcCode添加了两个私有函数，SrcCode::insert()与SrcCode::expand()，分别是插入一条指令与展开一串指令。

逻辑上，被展开的指令是产生于当前正在处理的指令/伪指令，因此建议只允许向前插入指令。
