### 基于Sipeed Tang Nano 9k/20k的简易CPU/框架 v1

---

基于Sipeed Tang Nano 9k/20k的简易CPU/框架 v1

- [简介](#简介)
- [使用方法](#使用方法)
- [CPU结构简介](#CPU结构简介)
- [常量与指令集](#常量与指令集)
- [汇编器](#汇编器)
- [IO](#IO)
- [中断系统](#中断系统)
- [其它](#其它)



#### 简介

***

基于Tang Nano 9k/20k的简易CPU/框架。定长指令，哈佛结构，单周期设计。目前仅支持8bit版本，32bit版本正在测试中。

该项目使用Verilog在Tang FPGA上实现CPU。可以使用任意文本编辑器写适用于该CPU的汇编命令，然后使用C++进行从汇编到比特流的映射，写到Verilog的Gowin IP核初始化文件中烧入FPGA。

CPU部分被封装在单独的模块中，并将IO等资源引出，保证在添加外设时无需更改CPU内部结构。在该框架下可接任意IO以实现更加方便地进行软核 + FPGA的开发模式，所有IO都被连接到一块IO控制模块上映射到一个寄存器中。已支持UART、SPI等协议。

由于8bit版本最大只支持256条指令，所以暂不考虑在8bit版本中实装中断系统。



#### 使用方法

***

环境要求：

	1. C++11以上的编译环境
	1. 高云云源IDE

`\Verilog`下是CPU的实现，下载并在云源IDE中添加到工程中。

`\Cpp`下是汇编器的实现。

分别修改`\Cpp\main.cpp`中**SOURCE**和**TARGET**为你**汇编代码文本的路径**以及`\Verilog\src\ROM_32bit\ROM_32bit.v`（仅8bit版本下）的路径。之后运行main.cpp，当命令行显示Done并自动关闭时说明映射完毕，如果显示Wrong说明在代码中发现了错误。成功之后在高云云源中综合并烧录，烧录至你的FPGA即可。

如果你只需要需要一个能工作在FPGA上，但可以不像RISC-V那样专业的软核，作为一个简易的实现，你可以仅仅了解如何通过**指令集**让这块CPU工作即可。



#### CPU结构简介

***

8bit版本设计如下：

 1. 存在三条总线，#A、#B两条用来提供计算输入/寄存器输出，#C用来提供计算输出/寄存器输入；

 2. 共有16个寄存器，其中#0到#11作为通用寄存器。#12被称作IOAD，#13被称作IOC，#14被称作Timer，#15被称作PC。寄存器会从#C上获取数据，会将数据输出到#A或#B上。

    (1) IOC是输入输出控制模块，该模块被封装为寄存器，其行为对于CPU而言与普通寄存器相同，用来对不同IO进行管理。

    (2) IOAD用来区分当前选中的IO模块，具体而言，IOAD低四位用来指示可能存在的IO内部寄存器地址，其它高位用来指示当前选中的IO。

    (3) Timer是定时器寄存器，寄存器中的值会不断自增，从0开始自增256次后到下一次0所用时间需要0.99999289s，同1s比误差小于1e-5。是在不使用中断时感知时间的一种手段。

    (4) PC是程序计数器。

 3. RAM、ROM使用Tang上的BSRAM实现。指令存在ROM中，定长32bit；

 4. ALU以及COND负责计算以及条件判断，会从#A和#B获取数据，其中ALU把计算结果输出到#C。



#### 常量与指令集

***

此处仅介绍指令集用法以供想要快速实现功能的人使用。常量与指令集不区分大小写，在映射程序中会同统一转到大写处理。常量与指令集都可以看作是一个常数的别名，所以它们之间都能互相运算。支持加、减、或、异或、与五种运算。

指令集主要可以分为四类，分别是运算指令，条件指令，访存指令和函数指令。

##### 常量

常量不是指令，但可以增加代码的可读性。

通用寄存器的命名规则是regxx，或者也可以用reg|xx、reg+xx等运算来表达。

- 8bit下，共有16个寄存器。#0 - #11是通用寄存器。剩下四个寄存器命名分别是：输入输出地址寄存器IOAD，输入输出控制器IOC，计时器TIMER，程序计数器PC。
- 32bit下，共有32个寄存器。#0 - #25是通用寄存器，之后依次是：宽立即数寄存器WIMM，中断控制器INTC，输入输出地址寄存器IOAD，输入输出控制器IOC，计时器TIMER，程序计数器PC。

向IOAD写入对IO的选择时，这里提供了对应的常量。比如spi是0，spi.flg（SPI的标志寄存器，参考高云IP核手册）是4，uart是16，uart.lsr（UART的线状态寄存器，参考高云IP核手册）是21，方便使用。

同时接受常数的二进制和十六进制的表达，使用0b或0x作为前缀。

还有两个特殊常量im1与im2。

- 8bit下和指令相或来表示该条指令的第一个或第二个参数是立即数，允许前两个参数都是立即数，不允许用户规定第三个参数是否为立即数。
- 32bit下用来表示第一个、第二个或第三个参数是短立即数（12bit），每条指令只允许一个参数是短立即数。

##### 运算指令

运算指令包括：add、sub、and、or、not、xor、mov、mull、mulh、lsh、rsh、div、mod、car。

其中mull和mulh是乘法，一个返回结果的低八位一个返回结果的高八位。lsh和rsh是逻辑左移和逻辑右移。car返回上一次加法是否进位。

除了mov和not这两个单目运算以及car这个输出进位标记的指令外，其余的双目运算均从前两个参数所示的寄存器/立即数取值，进行运算后赋值给第三个数所示的寄存器。

mov和not的第二个参数留空，用$\_$占位。car不接受前两个参数。

```
add|im2 reg1 1 reg1
mov|im1 10 _ reg5
car _ _ reg2
```

##### 条件指令

条件指令包括：je、jne、js、jse、jg、jge、jmp。

条件指令第三个参数一定是一个常数，或者说是一条label名，满足条件时将这个数覆盖到PC中去。

jmp是无条件跳转，不接受前两个参数，PC会无条件跳转到第三个参数指示的位置。其它六条指令接受前两个参数指示的寄存器/立即数，当为真时跳转到第三个参数所示的位置。j是judge，s是smaller，g是greater，e是equal。

```
lebel loop_1
	je|im2 reg1 10 loop_1
```

##### 访存指令

访存指令包括：memr、memw。

这两条指令都会把第二个参数指示的寄存器/立即数作为地址输入到RAM中。

当指令为memr时，指令不接受第一个参数，会把读到的值赋值给第三个参数指示的寄存器。

当指令为memw时，指令不接受第三个参数，会把第一个参数指示的寄存器/立即数写入RAM对应的地址上。

```
memr|im2 reg10 0x0a _
memw _ reg7 reg8
```

##### 函数指令

函数指令包括：call、ret、int(仅32bit)、iret(仅32bit)。

call不接受前两个参数，第三个参数的要求同条件指令一样。会先将PC当前的值+1后压入PC模块内一个32字节的栈中，在这之后call的行为相当于jmp。

ret不接受任何参数，仅仅是指示PC将栈顶元素出栈并覆盖PC当前的值。

int接受第二个参数，COND会拉高对应的中断使得PC跳转进软中断中。

iret不接受任何参数，指令解码器ID会拉高中断撤销信号来让中断控制器结束本次中断。

```
label func
	add reg1 reg2 reg1
	ret _ _ _

call _ _ func
```

##### 其它指令（仅32bit）

目前仅有一条wimm，用来生成宽立即数。

##### 伪指令

目前支持的伪指令仅有一条：label。

使用label xxx来使得xxx变为它下面一行指令的行号，label会在代码文件开始被映射到比特流之前被展开并识别。



#### 汇编器

***

汇编器将汇编代码映射到机器码，写入ROM模块中。

步骤如下：

 1. 读取table文件。在std::map中储存指令或者常量对应的值。

 2. 预处理所有伪指令。由于当前伪指令只有LABEL，所以这一步就是在处理LABEL。将所有LABEL作为一个常量写入map中。

    这里存在一个bug。label的名称不应该与任何一个已经存在于map中的键相同。

 3. 处理所有程序，并进行映射。

 4. 写入文件。



8bit版本中每条指令（一行）4个字节：

```
 7:0      15:8     23:16    31:24
opcode    para1    para2    para3
1Byte     1Byte    1Byte    1Byte
```



32bit中每条指令（一行）4个字节：

不存在立即数的普通指令：

```
1:0     9:2      14:10    19:15    24:20
imm    opcode    para1    para2    para3
 2b      8b       5b       5b       5b
```

存在立即数的普通指令：

```
1:0     9:2      14:10    19:15    31:20
imm    opcode    para1    para2     imm
 2b      8b       5b       5b       12b
```



#### IO

***

CPU模块对外部提供一个4位的**片内地址线**以及一个inout类型的**数据总线**，并为每个外设提供一个**读\写信号**和一个高有效的**片选信号**。

模板如下：

```verilog
module Template
(
	input   wire            clk,
    input   wire            rst_n,

    inout   wire[31:0]      data_io,
    input   wire            cs_en,
    input   wire            wrx,
    input   wire[3:0]       addr_in
    
    /*
    自定义接口
    */
);
    wire[31:0]  wdata;
    wire[31:0]  rdata;
    assign wdata = wrx ? data_io : 32'dz;
    assign data_io = cs_en ? (wrx ? 32'dz : rdata) : 32'dz;
    
    /*
    自定义行为
    */
    
endmodule
```

**以下内容仅针对32bit版本。**

CPU自身占用了0号到15号的IO。

除一般IO模块外，某些功能的配置寄存器也会被放到IO中，这些被CPU占用的IO包括：

- 0号：中断使能寄存器组。
- 1号：基址寄存器组。用来配置代码基址、内存基址、栈指针。
- 2号：boot选择寄存器。用来选择向内存还是指令内存中写入，比如从某些存储设备（如TF卡）中加载指令。
- 8号：UART0。
- 9号：UART1。
- 10号：SPI。
- 其余保留。

CPU默认提供32个IO接口，对外部提供16个，可以通过顶部模块的IONUM参数进行配置。

由于IOAD内的值低4位被用作片内寄存器地址使用，所以最大IO数不建议超过256个，否则IO编号将超过立即数的范围，需要额外两个周期生成宽立即数。



#### 中断系统

***

**以下内容仅针对32bit版本。**

目前的中断控制器支持255优先级中断，低级中断会被高级中断打断，中断号越低优先级越高。

- 0号 - 63号：软中断。
- 64号 - 127号：定时器中断。
- 128号 - 254号：外部中断。
- 255号：作为无中断时的默认中断号被CPU本身占用。

CPU向外部提供192号 - 254号共47个中断端口，其余被保留。



中断控制器可能在之后的版本中会被改成127级或者63级。



#### 其它

***

如果你也是一名初学者，并且对CPU的实现感兴趣的话，你应该需要：

前置知识：C++、数字电子技术、Verilog、计算机组成（微机原理、接口技术）等。

推荐《CPU自制入门》作为入门书籍，本书可以为初学者提供一些思路。

推荐游戏《Turing Complete》，steam在售。教玩家从一个与非门开始搓出一整套计算机并使用汇编实现一些功能，贯穿了从数电基础开始到计算机组成的知识点。

这是一个将数门课程综合运用的一个过程。

实际上该项目最初的实现就是由我在《Turing Complete》中实现的CPU发展而来。并用在了2023年年初西南科技大学开设的处理器项目设计中。

